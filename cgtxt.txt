6.To draw a simple shaded scene consisting of a tea pot on a table. Define suitably the 
position and properties of the light source along with the properties of the surfaces of 
the solid object used in the scene. 
Refer:Text-2: Topic: Lighting and Shading 
 
#include<glut.h> 
void teapot(GLfloat x, GLfloat y, GLfloat z) 
{ 
 glPushMatrix(); //save the current state 
 glTranslatef(x, y, z); //move your item appropriately 
 glutSolidTeapot(0.1); //render your teapot 
glPopMatrix(); //get back your state with the recent changes that you have done 
} 
void tableTop(GLfloat x, GLfloat y, GLfloat z) // table top which is actually a CUBE 
{ 
 glPushMatrix(); 
 glTranslatef(x, y, z); 
 glScalef(0.6, 0.02, 0.5); 
 glutSolidCube(1); 
 glPopMatrix(); 
} 
void tableLeg(GLfloat x, GLfloat y, GLfloat z) // table leg which is actually a CUBE 
{ 
 glPushMatrix(); 
 glTranslatef(x, y, z); 
 glScalef(0.02, 0.3, 0.02); 
 glutSolidCube(1); 
 glPopMatrix(); 
} 
void wall(GLfloat x, GLfloat y, GLfloat z) // wall which is actually a CUBE 
{ 
 glPushMatrix(); 
 glTranslatef(x, y, z); 
 glScalef(1, 1, 0.02); 
 glutSolidCube(1); 
 glPopMatrix(); 
} 
void light() // set the lighting arrangements 
{ 
 GLfloat mat_ambient[] = { 1, 1, 1, 1 }; // ambient colour 
 GLfloat mat_diffuse[] = { 0.5, 0.5, 0.5, 1 }; 
 GLfloat mat_specular[] = { 1, 1, 1, 1 }; 
 GLfloat mat_shininess[] = { 50.0f }; // shininess valueglMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient); 
 glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse); 
 glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular); 
 glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess); 
 GLfloat light_position[] = { 2, 6, 3, 1 }; 
 GLfloat light_intensity[] = { 0.7, 0.7, 0.7, 1 }; 
 glLightfv(GL_LIGHT0, GL_POSITION, light_position); 
 glLightfv(GL_LIGHT0, GL_DIFFUSE, light_intensity); 
} 
void display() 
{ 
 GLfloat teapotP = -0.07, tabletopP = -0.15, tablelegP = 0.2, wallP = 0.5; 
 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
 glLoadIdentity(); 
 gluLookAt(-2, 2, 5, 0, 0, 0, 0, 1, 0); // camera position & viewing 
 light(); //Adding light source to your project 
 teapot(0, teapotP, 0); //Create teapot 
 tableTop(0, tabletopP, 0); //Create tableâ€™s top 
 tableLeg(tablelegP, -0.3, tablelegP); //Create 1st leg 
 tableLeg(-tablelegP, -0.3, tablelegP); //Create 2nd leg 
 tableLeg(-tablelegP, -0.3, -tablelegP); //Create 3rd leg 
 tableLeg(tablelegP, -0.3, -tablelegP); //Create 4th leg 
 wall(0, 0, -wallP); //Create 1st wall 
 glRotatef(90, 1, 0, 0); 
 wall(0, 0, wallP); //Create 2nd wall 
 glRotatef(90, 0, 1, 0); 
 wall(0, 0, wallP); //Create 3rd wall 
 glFlush(); // show the output to the user 
} 
void init() 
{ 
 glClearColor(0, 0, 0, 1); // black colour background 
 glMatrixMode(GL_PROJECTION); 
 glLoadIdentity(); 
 glOrtho(-1, 1, -1, 1, -1, 10); 
 glMatrixMode(GL_MODELVIEW); 
} 
int main(int argc, char** argv) 
{ 
 glutInit(&argc, argv); 
 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH); 
 glutInitWindowSize(500, 500); 
 glutInitWindowPosition(0, 0); 
glutCreateWindow("Teapot on a table");
 init();
 glutDisplayFunc(display);
 glEnable(GL_LIGHTING); // enable
 the lighting properties
 glEnable(GL_LIGHT0); // enable the light source
 glShadeModel(GL_SMOOTH); // for smooth shading (select flat or smooth shading)
 glEnable(
 GL_NORMALIZE); // If enabled and no vertex shader is active, normal 
//vectors  are normalized to unit length after transformationand beforelighting.
 glEnable(GL_DEPTH_TEST); // do depth comparisons and update the depth buffer.
 glutMainLoop();
 }



7.Design, develop and implement recursively subdivide a tetrahedron to form 3D 
sierpinski gasket. The number of recursive steps is to be specified by the user. 
Refer: Text-2: Topic: sierpinski gasket. 
#include<stdlib.h> 
#include<stdio.h> 
#include<glut.h> 
 
typedef float point[3]; 
point v[] = { {0.0,0.0,1.0}, 
  {0.0,0.9,0.3}, 
  {-0.8,-0.4,-0.3}, 
  {0.8,-0.4,-0.3} }; 
int n; 
void triangle(point a, point b, point c) 
{ 
 glBegin(GL_POLYGON); 
 glVertex3fv(a); 
 glVertex3fv(b); 
 glVertex3fv(c); 
 glEnd(); 
} 
void divide_triangle(point a, point b, point c, int m) 
{ 
 point v1, v2, v3; 
 int j; 
 if (m > 0) 
 { 
  for (j = 0; j < 3; j++) 
   v1[j] = (a[j] + b[j]) / 2; 
  for (j = 0; j < 3; j++) 
   v2[j] = (a[j] + c[j]) / 2; 
  for (j = 0; j < 3; j++) 
   v3[j] = (b[j] + c[j]) / 2; 
  divide_triangle(a, v1, v2, m - 1); 
  divide_triangle(c, v2, v3, m - 1); 
  divide_triangle(b, v3, v1, m - 1); 
 } 
 else(triangle(a, b, c)); 
} 
void tetrahedron(int m) 
{ 
 glColor3f(1.0, 0.0, 0.0); 
 divide_triangle(v[0], v[1], v[2], m); 
glColor3f(0.0, 1.0, 0.0); 
 divide_triangle(v[3], v[2], v[1], m); 
 glColor3f(0.0, 0.0, 1.0); 
 divide_triangle(v[0], v[3], v[1], m); 
 glColor3f(0.0, 0.0, 0.0); 
 divide_triangle(v[0], v[2], v[3], m); 
} 
void display(void) 
{ 
 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
 glLoadIdentity(); 
 tetrahedron(n); 
 glFlush(); 
} 
void myReshape(int w, int h) 
{ 
 glViewport(0, 0, w, h); 
 glMatrixMode(GL_PROJECTION); 
 glLoadIdentity(); 
 if (w <= h)glOrtho(-2.0, 2.0, -2.0 * (GLfloat)h / (GLfloat)w, 2.0 * (GLfloat)h / 
(GLfloat)w, -10.0, 10.0); 
 else 
glOrtho(-2.0 * (GLfloat)w / (GLfloat)h, 2.0 * (GLfloat)w / (GLfloat)h, -.0, 2.0, -10.0, 
10.0); 
 glMatrixMode(GL_MODELVIEW); 
 glutPostRedisplay(); 
} 
int main(int argc, char** argv) 
{ 
 printf("Enter the number of division?"); 
 scanf_s("%d", &n); 
 glutInit(&argc, argv); 
 glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH); 
 glutInitWindowSize(500, 500); 
 glutCreateWindow("3D Gasket"); 
 glutReshapeFunc(myReshape); 
 glutDisplayFunc(display); 
 glEnable(GL_DEPTH_TEST); 
 glClearColor(1.0, 1.0, 1.0, 1.0); 
 glutMainLoop(); 
} 




8.Develop a menu driven program to animate a flag using Bezier Curve algorithm 
Refer: Text-1: Chapter 8-10 
#include<stdio.h> 
#include<glut.h> 
#include<math.h> 
#define Pi 3.1416 
typedef struct point 
{ 
 GLfloat x, y, z; 
}; 
void bino(int n, int* c) 
{ 
 int k, j; 
 for (k = 0; k <= n; k++) 
 { 
  c[k] = 1; 
  for (j = n; j >= k + 1; j--) 
   c[k] *= j; 
  for (j = n - k; j >= 2; j--) 
   c[k] /= j; 
 } 
} 
void computebezPt(float u, point* pt1, int cPt, point* pt2, int* c) 
{ 
 int k, n = cPt - 1; 
 float bFcn; 
 pt1->x = pt1->y = pt1->z = 0.0; 
 for (k = 0; k < cPt; k++) 
 { 
  bFcn = c[k] * pow(u, k) * pow(1 - u, n - k); 
  pt1->x += pt2[k].x * bFcn; 
  pt1->y += pt2[k].y * bFcn; 
  pt1->z += pt2[k].z * bFcn; 
 } 
} 
void bezier(point* pt1, int cPt, int bPt) 
{ 
 point bcPt; 
 float u; 
 int* c, k; 
 c = new int[cPt]; 
 bino(cPt - 1, c); 
 glBegin(GL_LINE_STRIP); 
for (k = 0; k <= bPt; k++) 
 { 
  u = float(k) / float(bPt); 
  computebezPt(u, &bcPt, cPt, pt1, c); 
  glVertex2f(bcPt.x, bcPt.y); 
 } 
 glEnd(); 
 delete[]c; 
} 
float theta = 0; 
void display() 
{ 
 glClear(GL_COLOR_BUFFER_BIT); 
 int nctrlPts = 4, nBcPts = 20; 
 point ctrlPts[4] = { {100,400,0},{150,450,0},{250,350,0},{300,400,0} }; 
 // for animating the flag 
 ctrlPts[1].x += 50 * sin(theta * Pi / 180.0); 
 ctrlPts[1].y += 25 * sin(theta * Pi / 180.0); 
 
 ctrlPts[2].x -= 50 * sin((theta + 30) * Pi / 180.0); 
 ctrlPts[2].y -= 50 * sin((theta + 30) * Pi / 180.0); 
 
 ctrlPts[3].x -= 25 * sin((theta)*Pi / 180.0); 
 ctrlPts[3].y += 25 * sin((theta - 30) * Pi / 180.0); 
 
 theta += 0.2; //animating speed 
 glClear(GL_COLOR_BUFFER_BIT); 
 glColor3f(1.0, 1.0, 1.0); 
 glPointSize(5); 
 glPushMatrix(); 
 glLineWidth(5); 
 glColor3f(1.0, 0.4, 0.2); //Indian flag: Saffron color code 
 for (int i = 0; i < 50; i++) 
 { 
  glTranslatef(0.0, -0.8, 0.0); 
  bezier(ctrlPts, nctrlPts, nBcPts); 
 } 
 glColor3f(1, 1, 1); 
 for (int i = 0; i < 50; i++) 
 { 
  glTranslatef(0, -0.8, 0); 
  bezier(ctrlPts, nctrlPts, nBcPts); 
 } 
glColor3f(0, 1, 0); 
 for (int i = 0; i < 50; i++) 
 { 
  glTranslatef(0, -0.8, 0); 
  bezier(ctrlPts, nctrlPts, nBcPts); 
 } 
 glPopMatrix(); 
 glColor3f(0.7, 0.5, 0.3); //pole colour 
 glLineWidth(5); 
 glBegin(GL_LINES); 
 glVertex2f(100, 400); 
 glVertex2f(100, 40); 
 glEnd(); 
 glutPostRedisplay(); 
 glutSwapBuffers(); 
} 
void init() 
{ 
 glMatrixMode(GL_PROJECTION); 
 glLoadIdentity(); 
 gluOrtho2D(0, 500, 0, 500); 
} 
int main(int argc, char** argv) 
{ 
 glutInit(&argc, argv); 
 glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB); 
 glutInitWindowPosition(0, 0); 
 glutInitWindowSize(500, 500); 
 glutCreateWindow("Bezer Curve Algorithm"); 
 init(); 
 glutDisplayFunc(display); 
 glutMainLoop(); 
 return 0; 
} 



9. Develop a menu driven program to fill the polygon using scan line algorithm 
#include<stdio.h> 
#include<glut.h> 
#include<stdlib.h> 
float LE[500], RE[500]; 
int  Edgeflag = 0, FillFlag = 0; 
void Menu(int id) 
{ 
 if (id == 1) 
  Edgeflag = 1; 
 else if (id == 2) 
  Edgeflag = 0; 
 else if (id == 3) 
  exit(0); 
 FillFlag = 1; 
 glutPostRedisplay(); 
} 
void MyInit() 
{ 
 glMatrixMode(GL_PROJECTION); 
 glLoadIdentity(); 
 gluOrtho2D(0, 500, 0, 500); 
 glMatrixMode(GL_MODELVIEW); 
 glutCreateMenu(Menu); 
 glutAddMenuEntry("with Edge", 1); 
 glutAddMenuEntry("without Edge", 2); 
 glutAddMenuEntry("Exit", 3); 
 glutAttachMenu(GLUT_RIGHT_BUTTON); 
} 
void intersection_point(GLint x1, GLint y1, GLint x2, GLint y2) 
{ 
 float M, x; 
 int t, y; 
 if (y1 > y2) 
 { 
  t = x1; 
  x1 = x2; 
  x2 = t; 
  t = y1; 
  y1 = y2; 
  y2 = t; 
 } 
 if ((y2 - y1) == 0) 
M = (x2 - x1); 
 else 
  M = (x2 - x1) / (y2 - y1); 
 x = x1; 
 for (y = y1; y <= y2; y++) 
 { 
  if (x < LE[y]) 
   LE[y] = x; 
  if (x > RE[y]) 
   RE[y] = x; 
 x = x + M; 
 } 
} 
void Draw() 
{ 
 GLint P1[2] = { 125,250 }, P2[2] = { 250,125 }, P3[2] = { 375,250 }, P4[2] = { 
250,375 }; 
 glClear(GL_COLOR_BUFFER_BIT); 
 for (int i = 0; i < 500; i++) 
 { 
  LE[i] = 500; 
  RE[i] = 0; 
 } 
 if (Edgeflag == 1) 
 { 
  glBegin(GL_LINE_LOOP); 
  glVertex2iv(P1); 
  glVertex2iv(P2); 
  glVertex2iv(P3); 
  glVertex2iv(P4); 
  glEnd(); 
 } 
 intersection_point(P1[0], P1[1], P2[0], P2[1]); 
 intersection_point(P2[0], P2[1], P3[0], P3[1]); 
 intersection_point(P3[0], P3[1], P4[0], P4[1]); 
 intersection_point(P4[0], P4[1], P1[0], P1[1]); 
 if (FillFlag == 1) 
 { 
  for (int y = 0; y < 500; y++) 
  { 
   for (int x = LE[y]; x < RE[y]; x++) 
   { 
    glBegin(GL_POINTS); 
glVertex2i(x, y); 
    glEnd(); 
    glFlush(); 
   } 
  } 
 } 
 glFlush(); 
} 
int main(int argc, char** argv) 
{ 
 glutInit(&argc, argv); 
 glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); 
 glutInitWindowSize(500, 500); 
 glutInitWindowPosition(10, 50); 
 glutCreateWindow("polygon fill"); 
 MyInit(); 
 glutDisplayFunc(Draw); 
 glutMainLoop(); 
 return 0; 
} 